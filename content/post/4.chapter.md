+++
author = ""
date = "2017-02-17T11:17:20+09:00"
description = ""
tags = []
title = "4.chapter"

+++

## 칸반 앱 : 애니메이션과 드래그 앤드 드롭 지원

##### 카드 토글 애니메이션

* 애니메이션 적용을 위해 ReactCSSTransitionGroup 애드온 이용

```
npm install --save react-addons-css-transition-group
```

* Card.js 소스

``` html
// 전략
<ReactCSSTransitionGroup transitionName="toggle"
                         transitionEnterTimeout={250}
                         transitionLeaveTimeout={250} >
    {cardDetails}
</ReactCSSTransitionGroup>
// 후략
```

* transitionName으로 toggle을 썼으니 css에도 적용

``` css
.toggle-enter {
  max-height: 0;
  overflow: hidden;
}

.toggle-enter.toggle-enter-active {
  max-height: 300px;
  overflow: hidden;
  transition: max-height .25s ease-in;
}

.toggle-leave {
  max-height: 300px;
  overflow: hidden;
}

.toggle-leave.toggle-leave-active {
  max-height: 0;
  overflow: hidden;
  transition: max-height .25s ease-out;
}
```

##### 카드 드래그

* 카드 정렬 및 드래그 (타 리스트로 이동 가능, 위치 변경)
* 리액트 DND2와 HTML5 백엔드 설치

```
npm install --save react-dnd@2.x.x react-dnd-html5-backend@1.x.x
```

* KanbanAppContainer 컴포넌트에 카드 상태(카드가 속한 리스트)를 업데이트하는 메서드와 카드 위치를 업데이트 하는 메서드를 새롭게 생성
* KanbanBoardContainer.js 소스

``` html

// 전략
updateCardStatus(cardId, listId) { ... // 다른 리스트 위로 진행할 때 실행 (카드 상태 업데이트)

updateCardposition(cardId, afterId) { ... // 다른 카드 위로 드래그할 때 실행 (카드 위치 업데이트)
//중략

 <KanbanBoard cards={this.state.cards}
                         taskCallbacks={{
                            toggle: this.toggleTask.bind(this),
                            delete: this.deleteTask.bind(this),
                            add: this.addTask.bind(this)
                          }}
                         cardCallbacks={{
                            updateStatus: this.updateCardStatus.bind(this),
                            updatePosition: this.updateCardPosition.bind(this)
                         }}
                 />
```

* cardCallbacks 객체를 KanbanBoard 컴포넌트로 전달
* cardCallbacks 함수는 리스트 컴포넌트(카드를 다른 리스트 위로 드래그)와 카드 자체(나중에 정렬 기능 만들 때)에서 모두 호출되므로 이 속성을 받고 전달하도록 계층에서 둘 사이에 있는 모든 컴포넌트를 수정해야한다.
-\> KanbanBoard와 List 수정
* KanbanBoard.js 소스

``` html
// 전략
<List id='done'
      title='Done'
      cards={this.props.cards.filter((card) => card.status === "done")}
      cardCallbacks={this.props.cardCallbacks}
      taskCallbacks={this.props.taskCallbacks}/>

KanbanBoard.propTypes = {
        cards: PropTypes.arrayOf(PropTypes.object),
        taskCallbacks: PropTypes.object,
        cardCallbacks: PropTypes.object
};

export default KanbanBoard;
```

* 카드 드래그 앤드 드롭을 위한 마무리로 constants.js 파일 생성 및 CARD 형식 선언

``` javascript
export default {
    CARD : 'card'
}
```

##### 다른 리스트 사이로 드래그
* DropSource로 설정할 Card 컴포넌트부터 시작

```javascript
// 전략
const cardDragSpec = {
    beginDrag(props) {
        return {
            id: props.id,
            status: props.status
        }
    },
    endDrag(props) {
        props.cardCallbacks.persistCardDrag(props.id, props.status);
    }
}

let collectDrag = (connect, monitor) => {
    return {
        connectDragSource : connect.dragSource()
    };
}

// 중략

    render() {
        const { connectDragSource } = this.props;
        
        let cardDetails;
        if (this.state.showDetails) {...}
        
        let sideColor = {...}
        
        return connectDragSource(...
        
// 중략

Card.propTypes = {
    id: PropTypes.number,
    title: titlePropType,
    description: PropTypes.string,
    color: PropTypes.string,
    tasks: PropTypes.arrayOf(PropTypes.object),
    taskCallbacks: PropTypes.object,
    cardCallbacks: PropTypes.object,
    connectDragSource: PropTypes.func.isRequired
};
        
export default DragSource(constants.CARD, cardDragSpec, collectDrag) (Card);
```

##### 카드 정렬
* 리액트 Dnd를 이용해 항목 정렬을 구현할 때 핵심은 **한 요소를 DragSource와 DropTarget** 으로 함께 설정하는 것.
* 그로 인해 사용자가 드래그할 때 hover 핸들러로 어떤 요소 위로 드래그하는지 감지하고 위치 변경이 가능
* 예제에서 Card가 DragSource로 설정, 이젠 DropTarget으로 함께 설정하자.

```javascript

// 전략
const cardDropSpec = {
    hover(props, monitor) {
        const draggedId = monitor.getItem().id;
        props.cardCallbacks.updatePosition(draggedId, props.id);
    }
}

// 중략

let collectDrop = (connect, monitor) => {
    return {
        connectDropTarget : connect.dropTarget()
    };
}

// 중략
render() {
        const { connectDragSource, connectDropTarget} = this.props;
        let cardDetails;
        
// 중략

return connectDropTarget( connectDragSource(
            <div className="card">
                <div style={sideColor}/>
                
// 중략

Card.propTypes = {
    id: ...
    .
    .
    connectDragSource: PropTypes.func.isRequired,
    connectDropTarget: PropTypes.func.isRequired
};

const dragHighOrderCard = DragSource(constants.CARD, cardDragSpec, collectDrag) (Card);
const dragDropHighOrderCard = DropTarget(constants.CARD, cardDropSpec, collectDrop) (dragHighOrderCard);

export default dragDropHighOrderCard;
```

##### 콜백에 스로틀(Throttle) 적용
* 현재까지의 소스로는 콜백이 너무 지나치게 호출된다.
    * 다른 카드 위로 드래그 시 updatePosition 호출
    * 다른 리스트 위로 드래그 시 updateStatus 호출
* 그러므로 성능 저하 이슈가 있을 수 있음
* throttle 함수는 원래 함수 function과 대기 시간 wait의 두  매개변수를 받고 반복적으로 호출되면 wait 밀리초당 최대 한번만 원래 함수를 호출.
* utils.js 생성하여 throttle 함수 추가
* KanbanBoardContainer에서 updateCardPosition과 updateCardStatus의 throttle 버전을 만들자.

* KanbanBoardContainer.js 소스

```javascript
// 전략
    constructor() {
        super(...arguments);
        this.state = {
            cards: [],
        };
        // 인수가 변경된 경우에만 updateCardStatus를 호출한다.
        this.updateCardStatus = throttle(this.updateCardPosition.bind(this));
        // 최대 500ms마다 (또는 인수가 변경된 경우) updateCardPosition을 호출한다.
        this.updateCardPosition = throttle(this.updateCardPosition.bind(this), 500);
    }
// 중략
    render() {
        return (
            <KanbanBoard cards={this.state.cards}
                         taskCallbacks={{
                            toggle: this.toggleTask.bind(this),
                            delete: this.deleteTask.bind(this),
                            add: this.addTask.bind(this)
                          }}
                         cardCallbacks={{
                            updateStatus: this.updateCardStatus,
                            updatePosition: this.updateCardPosition,
                            persistCardDrag: this.persistCardDrag.bind(this)
                         }}
                />
        )
    }
// 후략    
    
```

* 이제 사용자가 드래그를 끝내면 Card의 cardDragSpec을 이용해 persistDrag 콜백을 호출하면 된다.

```javascript
// 전략
const cardDragSpec = {
    beginDrag(props) {
        return {
            id: props.id,
            status: props.status
        }
    },
    endDrag(props) {
        props.cardCallbacks.persistCardDrag(props.id, props.status);
    }
}
// 후략
```
