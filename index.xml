<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React.js 스터디</title>
    <link>https://ne-mis.github.io/study-react.js/</link>
    <description>Recent content on React.js 스터디</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <copyright>MIS 개발실</copyright>
    <lastBuildDate>Thu, 09 Feb 2017 16:52:17 +0900</lastBuildDate>
    <atom:link href="https://ne-mis.github.io/study-react.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>컴포넌트를 이용한 애플리케이션 구축</title>
      <link>https://ne-mis.github.io/study-react.js/2017/02/09/3.chapter/</link>
      <pubDate>Thu, 09 Feb 2017 16:52:17 +0900</pubDate>
      
      <guid>https://ne-mis.github.io/study-react.js/2017/02/09/3.chapter/</guid>
      <description>

&lt;h2 id=&#34;chapter3-컴포넌트를-이용한-애플리케이션-구축&#34;&gt;Chapter3 컴포넌트를 이용한 애플리케이션 구축&lt;/h2&gt;

&lt;h3 id=&#34;속성-유효성-검사&#34;&gt;속성 유효성 검사&lt;/h3&gt;

&lt;p&gt;컴포넌트를 조합해 더 큰 컴포넌트를 만들고 재사용할 수 있음. 따라서 속성을 명시적으로 지정해야함 -&amp;gt; propTypes선언&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;propsTypes 선언의 두가지 장점&lt;/strong&gt;
   1. 언제든지 컴포넌트를 열고 어떤속성이 필요한지, 속성의 형식이 무엇인지 알 수 있다.
   2. 문제가 발생한 경우 리액트가 콘솔에 오류메세지를 출력해 어떤 속성이 잘못되거나 누락됐는지, 문제가 발생한 render 메서드가 무엇인지 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;propTypes는 클래스 생성자 속성으로 정의된다. 다음과 같은 Greeter 리액트 컴포넌트의 salutation 속성을 &lt;span style=&#34;color:#e11d21&#34;&gt;&lt;strong&gt;문자열이며 반드시 지정해야한다&lt;/strong&gt;&lt;/span&gt;는 사항을 명시하려면 아래와 같이 정의한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component, PropTypes } from &#39;react&#39;;
import {render } from &#39;react-dom&#39;;

class Greeter extends Component {
    render() {
        return (
            &amp;lt;h1&amp;gt;{this.props.salutation}&amp;lt;/h1&amp;gt;
        )
    }
}
Greeter.propTypes = {
    salutation: PropTypes.string.isRequired
}

render(&amp;lt;Greeter salutation = &amp;quot;Hello World&amp;quot; /&amp;gt;, document.getElementById(&#39;rood&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;propTypes의 요건이 충족되지 않으면 console.warn항목에 로깅된다.
필수인 항목과 반대로, 선택적인 속성에는 .isRequired를 생략하면 된다.&lt;/p&gt;

&lt;h4 id=&#34;속성기본값&#34;&gt;속성기본값&lt;/h4&gt;

&lt;p&gt;속성 기본값을 지정하려면 defaultProps 객체를 생성자 속성으로 정의한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component, PropTypes } from &#39;react&#39;;
import {render } from &#39;react-dom&#39;;

class Greeter extends Component {
    render() {
        return (
            &amp;lt;h1&amp;gt;{this.props.salutation}&amp;lt;/h1&amp;gt;
        )
    }
}

Greeter.propTypes = {
    salutation: PropTypes.string
}

Greeter.defaultProps = {
    salutation: &amp;quot;Hello World&amp;quot;
}

render(&amp;lt;Greeter /&amp;gt;, document.getElementById(&#39;rood&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와같이 salutation 속성을 제공하지 않았을경우 컴포넌트가 기본값 &amp;ldquo;Hello Worl&amp;rdquo;를 렌더링한다.&lt;/p&gt;

&lt;h4 id=&#34;기본제공되는-proptypes-유효성-검사기&#34;&gt;기본제공되는 propTypes 유효성 검사기&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트 기본형 PropTypes&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;유효성검사기&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;propTypes.array&lt;/td&gt;
&lt;td&gt;속성이 배열이어야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.bool&lt;/td&gt;
&lt;td&gt;속성이 부울값(true/false)이어야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.func&lt;/td&gt;
&lt;td&gt;속성이 함수여야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.number&lt;/td&gt;
&lt;td&gt;속성이 숫자(또는 구문 분석으로 숫자를 얻을 수 있는 값)여야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.object&lt;/td&gt;
&lt;td&gt;속성이 객체여야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.string&lt;/td&gt;
&lt;td&gt;속성이 문자열이어야 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;조합 기본형 PropTypes&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;유효성검사기&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;propTypes.oneOfType&lt;/td&gt;
&lt;td&gt;속성이 여러 형식 중 하나일 수 있다. 예 : &lt;br/&gt; PropTypes.oneOfTypes([&lt;br/&gt;                 PropTypes.string,&lt;br/&gt;PropTypes.number,&lt;br/&gt;PropTypes.instanceOf(Message)])&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.arrayOf&lt;/td&gt;
&lt;td&gt;속성이 특정 형식의 배열이어야 한다. 예 : &lt;br/&gt; PropTypes.arrayOf(PropTypes.number)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.objectOf&lt;/td&gt;
&lt;td&gt;속성이 특정 형식의 속성 값을 가진 객체여야 한다. 예 : &lt;br/&gt; PropTypes.objectOf(PropTypes.number)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.shape&lt;/td&gt;
&lt;td&gt;속성이 특정 형태를 가진 객체여야 한다. 동일한 속성의 집합이 필요하다. 예 : &lt;br/&gt; PropTypes.shape({&lt;br/&gt;color: PropTypes.string, &lt;br/&gt;fontSize: PropTypes.number&lt;br/&gt;})&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;특수 PropTypes&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;유효성검사기&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;propTypes.node&lt;/td&gt;
&lt;td&gt;속성이 렌더링 가능한 어떤 값이라도 될 수 있다.(숫자, 문자열, 요소, 배열).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.element&lt;/td&gt;
&lt;td&gt;속성이 리액트 요소여야 한다.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.instanceOf&lt;/td&gt;
&lt;td&gt;속성이 지정한 클래스의 인스턴스여야 한다(자바 스크립트의 instanceof 연산자를 이용한다). 예 : PropTypes.instanceOf(Message)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propTypes.oneOf&lt;/td&gt;
&lt;td&gt;속성이 열거형과 같이 특정한 범위의 값으로 한정돼야 한다. 예 : PropTypes.oneOf([&amp;lsquo;News&amp;rsquo;, &amp;lsquo;Photos&amp;rsquo;]).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;칸반-앱-속성-형식-정의&#34;&gt;칸반 앱: 속성 형식 정의&lt;/h4&gt;

&lt;p&gt;컴포넌트의 propTypes는 컴포넌트를 생성할 때 곧바로 선언하는 것이 좋다.&lt;/p&gt;

&lt;h4 id=&#34;커스텀-proptypes-유효성-검사기&#34;&gt;커스텀 propTypes 유효성 검사기&lt;/h4&gt;

&lt;p&gt;유효성검사기는 속성의 리스트, 검사할 속성의 이름, 컴포넌트의 이름을 받는 함수다. 검사한 속성이 유효한 경우 아무것도 반환하지 않지만, 속성이 잘못된 경우 Error 인스턴스를 반환해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;칸반 앱 예제&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component, PropTypes } from &#39;react&#39;;
import marked from &#39;marked&#39;;
import CheckList from &#39;./CheckList&#39;;

let titlePropType = (props, propName, componentName) =&amp;gt; {
    if (props[propName]) {
        let value = props[propName];
        if (typeof value !== &#39;string&#39; || value.length &amp;gt; 80) {
            return new Error(
                &#39;$[propName} in ${componentName} is longer than 80 characters&#39;
            );
        }
    }
}

class Card extends Component {
    ...
}

Card.propTypes = {
    ...
    title : titlePropType,
    ...
};

export default Card;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;컴포넌트-조합-전략과-모범-사례&#34;&gt;컴포넌트 조합 전략과 모범 사례&lt;/h3&gt;

&lt;h2 id=&#34;컴포넌트-조합-전략과-모범-사례-1&#34;&gt;컴포넌트 조합 전략과 모범 사례&lt;/h2&gt;

&lt;h3 id=&#34;상태-저장-컴포넌트-vs-순수-컴포넌트&#34;&gt;상태 저장 컴포넌트 vs 순수 컴포넌트&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;상태 저장 컴포넌트 : 상태(state)를 관리함&lt;/li&gt;
&lt;li&gt;순수 컴포넌트 : 데이터를 표시하는 역할만 수행
                   ( 단순히 속성을 전달 받고 이를 뷰에 렌더링! )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;컴포넌트는-대부분-순수-컴포넌트로-구성하는-것이-좋다&#34;&gt;컴포넌트는 대부분 순수 컴포넌트로 구성하는 것이 좋다!&lt;/h3&gt;

&lt;p&gt;-&amp;gt; 다수의 컴포넌트로 분산하면 관리하기 힘들고 애플리케이션의 작동 방식을 파악하기 어렵기 때문!&lt;/p&gt;

&lt;h3 id=&#34;어떤-컴포넌트가-상태-저장이어야-할까&#34;&gt;어떤 컴포넌트가 상태 저장이어야 할까?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;상태가 필요한 컴포넌트를 구분하는 것은 이해하기 어려움!&lt;/li&gt;
&lt;li&gt;4단계 검사 목록을 적용하여 구분한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;1. 해당하는 상태를 기준으로 무언가를 렌더링하는 모든 컴포넌트를 찾는다.
2. 공통 소유자 컴포넌트를 찾는다. (계층에서 상태를 필요로 하는 모든 컴포넌트의 상위에 있는 단일 컴포넌트)
3. 공통 소유자나 계층에서 더 상위에 있는 다른 컴포넌트가 상태를 소유해야 한다.
4. 해당 상태를 소유하기에 적절한 컴포넌트를 찾을 수 없는 경우 단순히 상태를 저장하기 위한 컴포넌트를 새로 만들고, 계층에서 공통 소유자 컴포넌트 위쪽에 추가한다.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;최상위 계층 컴포넌트를 찾고, 그 컴포넌트가 상태를 가지도록 한다.&lt;/li&gt;
&lt;li&gt;만약 적절한 컴포넌트가 없을 경우, 상태저장용 컴포넌트를 새로 만들고 가장 최상위에 위치시킨다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;간단한-연락처-앱을-만들어보자&#34;&gt;간단한 연락처 앱을 만들어보자.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ne-mis.github.io/study-react.js/study-react.js/img/스크린샷 2017-02-13 오후 9.36.49.png&#34; alt=&#34;스크린샷 2017-02-13 오후 9.36.49.png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class ContactsApp extends React.Component {
    render() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;SearchBar /&amp;gt;
                &amp;lt;ContactList contacts={this.props.contacts} /&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}

class SearchBar extends React.Component {
  render() {
    return &amp;lt;input type=&amp;quot;search&amp;quot; placeholder=&amp;quot;search&amp;quot;/&amp;gt;
  }
}

class ContactList extends React.Component {
  render() {
    return (
       &amp;lt;ul&amp;gt;
          {this.props.contacts.map(
            (contact) =&amp;gt; &amp;lt;ContactItem key={contact.email}
                           name={contact.name}
                           email={contact.email}/&amp;gt;
          )}
      &amp;lt;/ul&amp;gt;
    )
  }
}

class ContactItem extends React.Component {
  render(){
        return &amp;lt;li&amp;gt;{this.props.name} - {this.props.email}&amp;lt;/li&amp;gt;
    }
}

let contacts = [
    { name: &amp;quot;SampleA&amp;quot;, email:&amp;quot;SampleA@gmail.com&amp;quot; },
    { name: &amp;quot;SampleB&amp;quot;, email:&amp;quot;SampleB@gmail.com&amp;quot; },
    { name: &amp;quot;SampleC&amp;quot;, email:&amp;quot;SampleC@gmail.com&amp;quot; },
    { name: &amp;quot;SampleD&amp;quot;, email:&amp;quot;SampleD@gmail.com&amp;quot; },
    { name: &amp;quot;SampleE&amp;quot;, email:&amp;quot;SampleE@gmail.com&amp;quot; },
    { name: &amp;quot;SampleF&amp;quot;, email:&amp;quot;SampleF@gmail.com&amp;quot; }
];

ReactDOM.render(&amp;lt;ContactsApp contacts={contacts} /&amp;gt;, document.getElementById(&amp;quot;root&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;컴포넌트 4개는 모두 순수컴퍼넌트&lt;/li&gt;
&lt;li&gt;변경해야할 컴퍼넌트 : ContactList, SearchBar&lt;/li&gt;
&lt;li&gt;공통 최상위 컴퍼넌트 : ContactsApp&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;filtertext-속성을-통해-연락처-필터링-하기&#34;&gt;filterText 속성을 통해 연락처 필터링 하기&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// filterText의 상태와 handleUserInput 콜백을 속성을 통해 전달
class ContactsApp extends React.Component {
  constructor(){
    super();
    this.state={
      filterText :&#39;&#39;
    };
  }

  handleUserInput(searchTerm) {
    this.setState( {
            filterText : searchTerm
      })
  }

    render() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;SearchBar filterText={this.state.filterText}
                            onUserInput={this.handleUserInput.bind(this)}/&amp;gt;
                &amp;lt;ContactList contacts={this.props.contacts}
                              filterText={this.state.filterText}/&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// SearchBar 컴포넌트는 속성을 통해 콜백을 받고 입력 필드의 onChange 이벤트를 이용해 콜백을 호출

// 부모에서 속성을 통해 filterText(문자열)와 onUserInput(콜백 함수)을 전달 받음

class SearchBar extends React.Component {
  handleChange(event){
    this.props.onUserInput(event.target.value)
  }

  render() {
    return &amp;lt;input type=&amp;quot;search&amp;quot; placeholder=&amp;quot;search&amp;quot; value={this.props.filterText}
                  onChange={this.handleChange.bind(this)}/&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt; 이렇게 사용하면 순수컴포넌트 X&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  handleChange(event){
    this.setState({
        filterText : event.target.value
       })
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// 속성을 통해 contacts와 filterText를 전달받고, 연락처를 필터링 한 후 표시
class ContactList extends React.Component {
  render() {
    let filteredContacts = this.props.contacts.filter (
      (contact) =&amp;gt; contact.name.indexOf(this.props.filterText) !== -1
    );

    return (
       &amp;lt;ul&amp;gt;
          {filteredContacts.map(
            (contact) =&amp;gt; &amp;lt;ContactItem key={contact.email}
                           name={contact.name}
                           email={contact.email}/&amp;gt;
          )}
      &amp;lt;/ul&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
filter()
- 테스트를 통과한 요소가 있는 새로운 배열.
- 배열 내 각 요소에 대해 한 번 제공된 callback 함수를 호출해, callback이 true로 강제하는 값을 반환하는 모든 값이 있는 새로운 배열을 생성한다.

function isBigEnough(value) {
  return value &amp;gt;= 10;
}

var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered 는 [12, 130, 44]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고 :
&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&#34;&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class ContactItem extends React.Component {
  render(){
        return &amp;lt;li&amp;gt;{this.props.name} - {this.props.email}&amp;lt;/li&amp;gt;
    }
}

let contacts = [
    { name: &amp;quot;SampleA&amp;quot;, email:&amp;quot;SampleA@gmail.com&amp;quot; },
    { name: &amp;quot;SampleB&amp;quot;, email:&amp;quot;SampleB@gmail.com&amp;quot; },
    { name: &amp;quot;SampleC&amp;quot;, email:&amp;quot;SampleC@gmail.com&amp;quot; },
    { name: &amp;quot;SampleD&amp;quot;, email:&amp;quot;SampleD@gmail.com&amp;quot; },
    { name: &amp;quot;SampleE&amp;quot;, email:&amp;quot;SampleE@gmail.com&amp;quot; },
    { name: &amp;quot;SampleF&amp;quot;, email:&amp;quot;SampleF@gmail.com&amp;quot; }
];


ReactDOM.render(&amp;lt;ContactsApp contacts={contacts} /&amp;gt;, document.getElementById(&amp;quot;root&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;컴포넌트-수명주기&#34;&gt;컴포넌트 수명주기&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;컴포넌트의 특정 시점에 자동으로 호출될 메서드를 선언&lt;/li&gt;
&lt;li&gt;컴포넌트가 생성/삭제 시점에 특정한 작업을 수행&lt;/li&gt;
&lt;li&gt;성능최적화&lt;/li&gt;
&lt;li&gt;차후 플럭스 아키텍처 컴포넌트 구성에 필수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;수명주기-단계와-메서드&#34;&gt;수명주기 단계와 메서드&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;초기 컴포넌트 생성단계(&lt;strong&gt;&lt;span style=&#34;color:#0052cc&#34;&gt;마운팅&lt;/span&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;상태와 속성 변경(&lt;strong&gt;&lt;span style=&#34;color:#0052cc&#34;&gt;속성/상태 변경&lt;/span&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;트리거된 업데이트&lt;/li&gt;
&lt;li&gt;컴포넌트 언마운트 단계(&lt;strong&gt;&lt;span style=&#34;color:#0052cc&#34;&gt;언마운팅&lt;/span&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;마운팅&#34;&gt;마운팅&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1885895623800724352&#34; alt=&#34;새 파일 2017-02-05_2.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;render 전 후에 함수 수행되며 전에 수행된 함수는 render를 trigger하지 않는다.
render 후 에는 dom 이 완성되어 dom 에서 데이터를 가져 올 수 있다&lt;/p&gt;

&lt;h4 id=&#34;언마운팅&#34;&gt;언마운팅&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1885896324855246535&#34; alt=&#34;새 파일 2017-02-05_3.jpg&#34; /&gt;
언마운팅되기 직전에 호출. 정리작업에 유용&lt;/p&gt;

&lt;h4 id=&#34;속성변경&#34;&gt;속성변경&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1885896797475871207&#34; alt=&#34;새 파일 2017-02-05_4.jpg&#34; /&gt;
- componentWillReceiveProps: 컴포넌트가 새속성을 받는 함수. setState호출해도 추가 랜더링이 되지 않는다.
- shouldComponentUpdate: render를 생략가능하도록 설정할 수 있는 render 이전 함수. 성능 최적화에 유용한 함수.
- componentWillUpdate: render 직전 함수. 예정된 업데이트를 준비, setState사용 금지
- componentDidUpdate: 컴포넌트 update가 dom에 적용되고 난 직 후 호출&lt;/p&gt;

&lt;h4 id=&#34;상태변경&#34;&gt;상태변경&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1885919025498668809&#34; alt=&#34;새 파일 2017-02-05_5.jpg&#34; /&gt;
속성변경과 비슷한 생명 주기.
속성을 받는 함수인 componentWillReceiveProps 함수가 없다.
상태변경이 속성에 영향을 끼치진 않는다.&lt;/p&gt;

&lt;h3 id=&#34;수명주기-함수의-실제활용-데이터-가져오기&#34;&gt;수명주기 함수의 실제활용: 데이터 가져오기&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class ContactsAppContainer extends Component {
    constructor() {
        super();
        this.state = {
            contacts: []
        };
    }

//mount 생명주기 함수
//초기 랜더링 직후 dom 생성 후 호출
    componentDidMount() {
        fetch(&#39;./contacts.json&#39;)
        .then((response) =&amp;gt; response.json())
        .then((responseData) =&amp;gt; {
            this.setState({contacts: responseData})
        })
        .catch((error) =&amp;gt; {
            console.log(&#39;error&#39;, error);
        })
    }

    render() {
        return (
            &amp;lt;ContactsApp contacts={this.state.contacts}/&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;참고&#34;&gt;참고&lt;/h4&gt;

&lt;p&gt;폴리필(polyfill): 특정 기능을 지원하지 않는 브라우저에서 해당 기능을 이용 할 수 있게 해주는 브라우저 대체 기능.
해당 절에서는 whatwg-fetch라를 폴리필을 이용해 크롬/파폭 이외에서 fetch기능을 이용 할 수있게 했다. (원래는 window.fetch)&lt;/p&gt;

&lt;h3 id=&#34;불변성에-대한-개요-박병준-page-90-99&#34;&gt;불변성에 대한 개요 (@박병준, Page 90-99)&lt;/h3&gt;

&lt;h4 id=&#34;불변성-immutability-객체를-변경하지-않고-대체하는-것&#34;&gt;불변성(Immutability) : 객체를 변경하지 않고 대체하는 것&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;this.state를 직접 조작하는 것(mutable)은 리액트의 상태 관리를 우회하여 리액트의 패러다임을 위반하게 됨.&lt;/li&gt;
&lt;li&gt;리액트는 setState 메서드를 이용한 불변성을 지향함. (immutable)&lt;/li&gt;
&lt;li&gt;성능에도 영향 : 객체가 변경된 경우 편집된게 아니라 대체된 것이므로 훨씬 빠르게 객체 비교가 가능. ex) object1 == object2&lt;/li&gt;
&lt;li&gt;변경전 값을 관리하기에도 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;일반-자바스크립트에서의-불변성&#34;&gt;일반 자바스크립트에서의 불변성&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;일반 자바스크립트에서도 불변성은 가능하지만 표준은 아님.&lt;/li&gt;
&lt;li&gt;주의하지 않으면 객체가 대체되지 않고 의도치 않게 변형될 수 있기 때문.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;주의할점&#34;&gt;주의할점&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;잘못된 예&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let updatedPassengers = this.state.passengers;
updatePassengers.push(&#39;Mitchell, Vincent M.&#39;);
this.setState({passengers.updatePassengers});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;올바른 예&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let updatePassengers = this.state.passengers.concat(&#39;Mitchell, Vincent M.&#39;);
this.setState({passengers.updatePassengers});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[잘못된 예] 코드의 문제는 자바스크립트에서 객체와 배열은 참조로 전달된다는 점.&lt;/li&gt;
&lt;li&gt;비파괴 메서드(map, filter, concar 등)를 이용하여 새로운 객체를 만들어야 함.&lt;/li&gt;
&lt;li&gt;다른 대안으로 Object.assign 을 이용하여 새로운 객체를 생성하는 방법도 있음.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/ko-kr/library/dn858229(v=vs.94).aspx&#34;&gt;MSDN : Obejct.assign&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let updatedPassengers = Object.assign({}, this.state.passengers);
updatePassengers.push(&#39;Mitchell, Vincent M.&#39;);
this.setState({passengers.updatePassengers});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;중첩된-객체&#34;&gt;중첩된 객체&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;사실 위에서 설명한 비파괴 메서드나 Object.assign 은 깊은 복사를 하지 않음.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;즉, 새로 반환되는 객체의 중첩된 객체와 배열은 이전 객체에 있던 동일한 중첩된 객체와 배열을 참조.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let originalTicket = {
     company: &#39;Delta&#39;,
     flightNo: &#39;0990&#39;,
     departure: {
         airport: &#39;LAS&#39;,
         time: &#39;2016-08-21T10:00:00.000Z&#39;
     },
     arrival: {
         airport: &#39;MIA&#39;,
         time: &#39;206-08-21T14:00:00.000Z&#39;
     }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Do&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let newTicket = Object.assign({}, originalTicket, {flightNo &#39;5690&#39;});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Then&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;originalTicket
&amp;gt; Object {company: &amp;quot;Delta&amp;quot;, filghtNo: &#39;0990&#39;, departure:Object, arrival:Object}
     &amp;gt; arrival: Object
         airport: &amp;quot;MCO&amp;quot;
         time: &amp;quot;206-08-21T14:00:00.000Z&amp;quot;
&amp;gt; Object {company: &amp;quot;Delta&amp;quot;, filghtNo: &#39;0990&#39;, departure:Object, arrival:Object}
     &amp;gt; arrival: Object
         airport: &amp;quot;MCO&amp;quot;
         time: &amp;quot;206-08-21T14:00:00.000Z&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;&amp;gt; 리액트에서 변화감지 못함&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;깊은 복사를 만드는 방법이 있긴 하지만 성능면에서 부담이 있고 경우에 따라 깊은 복사가 불가능할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;리액트-불변성-도우미-react-immutablility-helper&#34;&gt;리액트 불변성 도우미(React Immutablility Helper)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.github.io/react/docs/update.html&#34;&gt;Facebook Immutablility Helper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;리액트의 애드온 패키지에는 update 라는 Immutablility Helper 가 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let newTicket = update(originalTicket, {
                     arrival: {
                         airport: {$set: &#39;MCO&#39;}
                     }
                 });
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let newTicket = update(originalTicket, {
                     codeshare: {
                         0: {$set: {company: &#39;AZ&#39;, flightNo: &#39;7320&#39;}}
                     }
                 });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;{$push: array} push() all the items in array on the target.&lt;/li&gt;
&lt;li&gt;{$unshift: array} unshift() all the items in array on the target.&lt;/li&gt;
&lt;li&gt;{$splice: array of arrays} for each item in arrays call splice() on the target with the parameters provided by theitem.&lt;/li&gt;
&lt;li&gt;{$set: any} replace the target entirely.&lt;/li&gt;
&lt;li&gt;{$merge: object} merge the keys of object with the target.&lt;/li&gt;
&lt;li&gt;{$apply: function} passes in the current value to the function and updates it with the new returned value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;칸반-앱-약간의-복잡성-추가&#34;&gt;칸반 앱 : 약간의 복잡성 추가&lt;/h3&gt;

&lt;h4 id=&#34;1-외부-api에서-초기-카드-가져오기&#34;&gt;1. 외부 API에서 초기 카드 가져오기&lt;/h4&gt;

&lt;p&gt;기존 하드 코딩을 제거하고 외부 API에서 초기 카드 값을 가져옴
&lt;a href=&#34;http://kanbanapi.pro-react.com/cards&#34;&gt;http://kanbanapi.pro-react.com/cards&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[{&amp;quot;id&amp;quot;:5698,&amp;quot;title&amp;quot;:&amp;quot;Read the Book&amp;quot;,&amp;quot;description&amp;quot;:&amp;quot;I should read the **whole** book&amp;quot;,&amp;quot;color&amp;quot;:&amp;quot;#BD8D31&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;todo&amp;quot;,&amp;quot;tasks&amp;quot;:[{&amp;quot;id&amp;quot;:20894,&amp;quot;name&amp;quot;:&amp;quot;elements&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20902,&amp;quot;name&amp;quot;:&amp;quot;application&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20828,&amp;quot;name&amp;quot;:&amp;quot;아이우에오&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20830,&amp;quot;name&amp;quot;:&amp;quot;ddd&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20903,&amp;quot;name&amp;quot;:&amp;quot;security&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20905,&amp;quot;name&amp;quot;:&amp;quot;react&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20896,&amp;quot;name&amp;quot;:&amp;quot;console&amp;quot;,&amp;quot;done&amp;quot;:true},{&amp;quot;id&amp;quot;:20895,&amp;quot;name&amp;quot;:&amp;quot;console&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20901,&amp;quot;name&amp;quot;:&amp;quot;profiles&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20900,&amp;quot;name&amp;quot;:&amp;quot;timeline&amp;quot;,&amp;quot;done&amp;quot;:true},{&amp;quot;id&amp;quot;:20897,&amp;quot;name&amp;quot;:&amp;quot;source&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20904,&amp;quot;name&amp;quot;:&amp;quot;audits&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20898,&amp;quot;name&amp;quot;:&amp;quot;elements&amp;quot;,&amp;quot;done&amp;quot;:true},{&amp;quot;id&amp;quot;:20899,&amp;quot;name&amp;quot;:&amp;quot;network&amp;quot;,&amp;quot;done&amp;quot;:true}]},{&amp;quot;id&amp;quot;:5699,&amp;quot;title&amp;quot;:&amp;quot;Write some code&amp;quot;,&amp;quot;description&amp;quot;:&amp;quot;Code along with the samples in the book at [github](https://github.com/pro-react)&amp;quot;,&amp;quot;color&amp;quot;:&amp;quot;#3A7E28&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;in-progress&amp;quot;,&amp;quot;tasks&amp;quot;:[{&amp;quot;id&amp;quot;:20883,&amp;quot;name&amp;quot;:&amp;quot;hamdi&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20888,&amp;quot;name&amp;quot;:&amp;quot;media&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20884,&amp;quot;name&amp;quot;:&amp;quot;xhr&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20892,&amp;quot;name&amp;quot;:&amp;quot;manifest&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20893,&amp;quot;name&amp;quot;:&amp;quot;other&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20891,&amp;quot;name&amp;quot;:&amp;quot;ws&amp;quot;,&amp;quot;done&amp;quot;:true},{&amp;quot;id&amp;quot;:20829,&amp;quot;name&amp;quot;:&amp;quot;카키구게코&amp;quot;,&amp;quot;done&amp;quot;:true},{&amp;quot;id&amp;quot;:20885,&amp;quot;name&amp;quot;:&amp;quot;js&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20886,&amp;quot;name&amp;quot;:&amp;quot;css&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20887,&amp;quot;name&amp;quot;:&amp;quot;img&amp;quot;,&amp;quot;done&amp;quot;:false},{&amp;quot;id&amp;quot;:20889,&amp;quot;name&amp;quot;:&amp;quot;font&amp;quot;,&amp;quot;done&amp;quot;:false}]}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-태스크-콜백을-속성과-연결&#34;&gt;2. 태스크 콜백을 속성과 연결&lt;/h4&gt;

&lt;p&gt;태스크를 조작하는 함수 (addTest, deleteTask, toogleTask) 생성 및 자식 컴포넌트에 속성 제공
새로운 함수가 추가될 때마다 props를 추가하는 방법이 아닌 단일 객체로 생성하여 전달하는 방법 사용
KanbanBoard, List, Card 컴포넌트와 연결
최종적으로 Card 컴포넌트에서 태스크 조작함수를 바인드하여 부모 컴포넌트로 콜백&lt;/p&gt;

&lt;h4 id=&#34;3-태스크-조작&#34;&gt;3. 태스크 조작&lt;/h4&gt;

&lt;p&gt;현재 상태를 직접 조작하지 않도록 Immutability Helpers를 사용&lt;/p&gt;

&lt;h4 id=&#34;4-기본적인-낙관적-업데이트-롤백&#34;&gt;4. 기본적인 낙관적 업데이트 롤백&lt;/h4&gt;

&lt;p&gt;원래 상태에 대한 참조를 저장 (let prevState = this.state;)&lt;/p&gt;

&lt;h4 id=&#34;5-code&#34;&gt;5. code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const API_URL = &#39;http://kanbanapi.pro-react.com&#39;;
const API_HEADERS = {
  &#39;Content-Type&#39;: &#39;application/json&#39;,
  Authorization: &#39;CHANGE THIS VALUE&#39;
};

class KanbanBoardContainer extends Component {
  constructor(){
    super(...arguments);
    this.state = {
      cards:[],
    };
  }
  componentDidMount(){
    fetch(API_URL+&#39;/cards&#39;, {headers: API_HEADERS})
    .then((response) =&amp;gt; response.json())
    .then((responseData) =&amp;gt; {
      this.setState({cards: responseData});
    })
    .catch((error) =&amp;gt; {
      console.log(&#39;Error fetching and parsing data&#39;, error);
    });
  }

  addTask(cardId, taskName){
    let prevState = this.state;
    let cardIndex = this.state.cards.findIndex((card)=&amp;gt;card.id == cardId);
    let newTask = {id:Date.now(), name:taskName, done:false};
    let nextState = update(this.state.cards, {
      [cardIndex]: {
        tasks: {$push: [newTask] }
      }
    });

    this.setState({cards:nextState});
    fetch(`${API_URL}/cards/${cardId}/tasks`, {
      method: &#39;post&#39;,
      headers: API_HEADERS,
      body: JSON.stringify(newTask)
    })
    .then((response) =&amp;gt; {
      if(response.ok){
        return response.json()
      } else {
        throw new Error(&amp;quot;Server response wasn&#39;t OK&amp;quot;)
      }
    })
    .then((responseData) =&amp;gt; {
      newTask.id=responseData.id
      this.setState({cards:nextState});
    })
    .catch((error) =&amp;gt; {
      this.setState(prevState);
    });
  }

  deleteTask(cardId, taskId, taskIndex){
    let prevState = this.state;
    let cardIndex = this.state.cards.findIndex((card)=&amp;gt;card.id == cardId);
    let nextState = update(this.state.cards, {
      [cardIndex]: {
        tasks: {$splice: [[taskIndex,1]] }
      }
    });
    this.setState({cards:nextState});
    fetch(`${API_URL}/cards/${cardId}/tasks/${taskId}`, {
      method: &#39;delete&#39;,
      headers: API_HEADERS
    })
    .then((response) =&amp;gt; {
      if(!response.ok){
        throw new Error(&amp;quot;Server response wasn&#39;t OK&amp;quot;)
      }
    })
    .catch((error) =&amp;gt; {
      console.error(&amp;quot;Fetch error:&amp;quot;,error)
      this.setState(prevState);
    });
  }

  toggleTask(cardId, taskId, taskIndex){
    let prevState = this.state;
    let cardIndex = this.state.cards.findIndex((card)=&amp;gt;card.id == cardId);
    let newDoneValue;
    let nextState = update(
      this.state.cards, {
        [cardIndex]: {
          tasks: {
            [taskIndex]: {
              done: { $apply: (done) =&amp;gt; {
                newDoneValue = !done
                return newDoneValue;
              }
            }
          }
        }
      }
    });

    this.setState({cards:nextState});
    fetch(`${API_URL}/cards/${cardId}/tasks/${taskId}`, {
      method: &#39;put&#39;,
      headers: API_HEADERS,
      body: JSON.stringify({done:newDoneValue})
    })
    .then((response) =&amp;gt; {
      if(!response.ok){
        throw new Error(&amp;quot;Server response wasn&#39;t OK&amp;quot;)
      }
    })
    .catch((error) =&amp;gt; {
      console.error(&amp;quot;Fetch error:&amp;quot;,error)
      this.setState(prevState);
    });
  }

  render() { return (
    &amp;lt;KanbanBoard cards={this.state.cards}
    taskCallbacks={{
      toggle: this.toggleTask.bind(this),
      delete: this.deleteTask.bind(this),
      add: this.addTask.bind(this) }} /&amp;gt;
    )
  }
}
export default KanbanBoardContainer;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>시작하기 / DOM 추상화의 내부</title>
      <link>https://ne-mis.github.io/study-react.js/2017/02/09/1-2.chapter/</link>
      <pubDate>Thu, 09 Feb 2017 16:33:57 +0900</pubDate>
      
      <guid>https://ne-mis.github.io/study-react.js/2017/02/09/1-2.chapter/</guid>
      <description>

&lt;h2 id=&#34;1장&#34;&gt;1장&lt;/h2&gt;

&lt;h3 id=&#34;민선유-리액트의-정의-리액트의-장점-3p&#34;&gt;민선유 : 리액트의 정의/리액트의 장점 3p&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;리액트의 정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;자바스크립트와 XML을 이용해 사용자 인터페이스를 구축하는 엔진.&lt;/li&gt;
&lt;li&gt;User Interface를 만들기 위한 Library.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;핵심개념 : 사용자 인터페이스의 생성과 유지 관리의 복잡성을 줄이는 것 !&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리액트의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;편리한 반응형 렌더링&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;개발자가 컴포넌트를 선언하면 리액트가 데이터 변경을 감지하고, 전체 인터페이스를 다시 렌더링&lt;/li&gt;
&lt;li&gt;가상 DOM을 이용해 UI의 현재 상태와 원하는 상태 비교 -&amp;gt; 변화된 부분만 수행 -&amp;gt; 빠르고 효율적으로 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;순수 자바 스크립트를 이용한 컴퍼넌트 기반 개발&lt;/li&gt;
&lt;li&gt;문서 모델의 유연한 추상화&lt;/li&gt;
&lt;li&gt;뛰어난 Garbage Collection , 메모리 관리 성능&lt;/li&gt;
&lt;li&gt;서버 &amp;amp; 클라이언트 렌더링 모두 지원&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;페이지 로드 후 ajax 호출시 자바스크립트 처리 후 UI -&amp;gt; 초기 로드시 느림
-&amp;gt; 초기에 서버사이드 렌더링 수행 -&amp;gt; 유저가 처음으로 컨텐츠를 보는 속도가 빨라짐&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;다른 프레임워크와 라이브러리와 혼용 가능 ( 특정 부분에서만 사용가능! )&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;view only : view 외의 기능은 직접 추가하거나 라이브러리를 이용&lt;/li&gt;
&lt;li&gt;IE8 이하 지원하지 않음!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;김성빈-첫-번째-리액트-앱-작성-7p&#34;&gt;김성빈: 첫 번째 리액트 앱 작성 7p&lt;/h3&gt;

&lt;h2 id=&#34;첫-번째-리액트-앱-작성&#34;&gt;첫 번째 리액트 앱 작성&lt;/h2&gt;

&lt;p&gt;리액트 컨포넌트의 기본 구조&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;render 메서드가 포함된 자바스크립트 클래스&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Hello extends React.Component {
    render() {
        return (
            \&amp;lt;h1\&amp;gt;Hello World\&amp;lt;/h1\&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jsx&#34;&gt;JSX&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;자바스크립트 코드 안에 XML(HTML)작성 가능&lt;/li&gt;
&lt;li&gt;선언식 구문&lt;/li&gt;
&lt;li&gt;javascript 로 변환(트랜스파일, transpile)하는 과정이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;리액트-개발-워크플로&#34;&gt;리액트 개발 워크플로&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JSX를 작성하고 즉석에서 일반 자바스크립트로 변환&lt;/li&gt;
&lt;li&gt;코드를 모듈 패턴으로 작성&lt;/li&gt;
&lt;li&gt;의존성 관리&lt;/li&gt;
&lt;li&gt;자바스크립트 파일을 번들로 만들고 디버깅을 위해 소스 맵을 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;리액트-프로젝트-기본구조&#34;&gt;리액트 프로젝트 기본구조&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;모든 자바스크립트를 포함하느 소스 폴더&lt;/li&gt;
&lt;li&gt;index.html - 리액트 애플리케이션의 자바스크립트를 로드하고 컴포넌트를 렌더링하는데 이용하는 div 를 제공&lt;/li&gt;
&lt;li&gt;package.json - npm 메니페스트 파일(기본정보, 의존성)&lt;/li&gt;
&lt;li&gt;모듈 패키지 또는 빌드 도구 - JSX변환과 모듈/의존성 번들 작업에 이용

&lt;ul&gt;
&lt;li&gt;Grunt, Gulp, Brunch, webpack(가장선호)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880951699313235751&#34; alt=&#34;새 파일 2017-02-05_1.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;빠르게-시작하기&#34;&gt;빠르게 시작하기&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//git clone
git clone https://github.com/mxstbr/react-boilerplate.git

//패키지(의존성) 관리
npm install

//애플리케이션 시작
npm start

//배포 빌드
npm run build
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;또는-직접-해보기&#34;&gt;또는 직접 해보기&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;/index.html 작성&lt;/li&gt;
&lt;li&gt;npm init&lt;/li&gt;
&lt;li&gt;package.json 수정&lt;/li&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;webpack.config.js 작성&lt;/li&gt;
&lt;li&gt;package.json script 추가&lt;/li&gt;
&lt;li&gt;npm start(아직 정상 실행 안됨, 컴포넌트 필요)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기까지 하면 의존성관리, 모듈시스템제공, JSX 를 변환하는 기본 프로젝트 구조 완성&lt;/p&gt;

&lt;h3 id=&#34;첫-컴포넌트-만들기&#34;&gt;첫 컴포넌트 만들기&lt;/h3&gt;

&lt;p&gt;./source/app.js 작성&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;

class Hello extends React.Component {
    render() {
        return (
            &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
        );
    }
}

React.render(&amp;lt;Hello /&amp;gt;, document.getElementById(&#39;root&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1878843671694597884&#34; alt=&#34;스크린샷 2017-02-05 오후 4.26.48.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;타이핑-수고를-약간-줄이는-방법&#34;&gt;타이핑 수고를 약간 줄이는 방법&lt;/h3&gt;

&lt;p&gt;모듈 임포트에 구조분해 할당(destructuring assignment) 을 적용하면
&lt;code&gt;React.Component&lt;/code&gt; -&amp;gt; &lt;code&gt;Componet&lt;/code&gt; 로 입력 가능하다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;

class Hello extends Component {
    render() {
        return (
            &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;동적-값&#34;&gt;동적 값&lt;/h3&gt;

&lt;p&gt;JSX에서 중괄호 &lt;code&gt;{ }&lt;/code&gt; 안에 있는 값은 자바스크립트 식으로 계산 되고 마크업 안에 렌더링 된다. 아래처럼 사용 가능&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;

class Hello extends Component {
    render() {
        var place = &#39;NHN ENT&#39;
        return (
            &amp;lt;h1&amp;gt;Hello {place}&amp;lt;/h1&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1878845802715010588&#34; alt=&#34;스크린샷 2017-02-05 오후 4.31.05.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;박병준-컴포넌트-조합하기-14p&#34;&gt;박병준: 컴포넌트 조합하기 14p&lt;/h3&gt;

&lt;p&gt;리액트는 재사용 가능한 비교적 간단한 컴포넌트들을 중첩하고 조합해서 보가 복잡한 UI를 만드는 방식을 권장함.&lt;/p&gt;

&lt;h5 id=&#34;기본적인-컴포넌트-조합예시&#34;&gt;기본적인 컴포넌트 조합예시&lt;/h5&gt;

&lt;p&gt;컴포넌트를 재사용하고 조합하는 것이 가장 중요한 이유는 컴포넌트의 구성을 커스터마이징 할 수 있기 때문이며,
컴포넌트 구성을 위해 리액트의 &lt;strong&gt;속성&lt;/strong&gt;을 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;속성은 &lt;strong&gt;부모 컴포넌트&lt;/strong&gt;에서 &lt;strong&gt;자식 컴포넌트&lt;/strong&gt;로 데이터를 전달하는 메커니즘이며,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;From 부모컴포넌트 -&amp;gt; To 자식컴포넌트
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;속성값의 설정은 부모컴포넌트의 역할이기 때문에 자식 컴포넌트에서 전달받은 속성을 변경할 수 없다. (immutable)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 부모 컴포넌트
class GroceryList extends Component {
    render() {
        return (
            &amp;lt;ul&amp;gt;
                &amp;lt;ListItem quantity=&amp;quot;1&amp;quot; name=&amp;quot;Bread&amp;quot; &amp;gt;blue&amp;lt;/ListItem&amp;gt;
                &amp;lt;ListItem quantity=&amp;quot;6&amp;quot; name=&amp;quot;Eggs&amp;quot; &amp;gt;red&amp;lt;/ListItem&amp;gt;
                &amp;lt;ListItem quantity=&amp;quot;2&amp;quot; name=&amp;quot;Milk&amp;quot; &amp;gt;black&amp;lt;/ListItem&amp;gt;
            &amp;lt;/ul&amp;gt;
        );
    }
}

// 자식 컴포넌트
class ListItem extends Component {
      render() {
        return (
            &amp;lt;li&amp;gt;
                {this.props.quantity} x {this.props.children} x {this.props.name}
            &amp;lt;/li&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;컴포넌트-계층-정의&#34;&gt;컴포넌트 계층 정의&lt;/h5&gt;

&lt;p&gt;인터페이스를 중첩된 컴포넌트로 분할하는 방법을 이해해야 하는데, 아래 3가지의 개념을 고려해야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. 컴포넌트는 단일 관심사를 가져야 하며 작아야 한다.&lt;/strong&gt;
&lt;strong&gt;즉, 컴포넌트는 한 가지 일만 해야 한다. 컴포넌트가 더 성장하는 경우 작은 하위 컴포넌트로 분할해야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2. 프로젝트의 와이어프레임와 레이아웃을 분석하면 컴포넌트 계층에 대한 많은 힌트를 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;3. 데이터 모델에 주목한다.
인터페이스와 데이터 모델은 동일한 정보 아키텍처를 따르는 예가 많기 때문에 UI를 컴포넌트로 분리하는 작업도 아주 쉽게 해결되는 경우가 많다.
즉, 데이터 모델의 한 조각을 나타내는 컴포넌트로 분리할 수 있다.&lt;/li&gt;
&lt;li&gt;칸반보드 앱의 데이터 모델&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[
    {
        id : 1,
        title : &amp;quot;card one title&amp;quot;,
        status : &amp;quot;todo&amp;quot;
        tasks : [
            {id: 1, name: &amp;quot;Task one&amp;quot;, done:true},
            {id: 2, name: &amp;quot;Task two&amp;quot;, done:false},
            {id: 3, name: &amp;quot;Task three&amp;quot;, done:false}
        ]
    },
    {
        id : 2,
        title : &amp;quot;card two title&amp;quot;,
        status : &amp;quot;in-progress&amp;quot;
        tasks : []
    }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 3가지 개념과 데이터 모델을 칸반 보드앱에 적용한다면 다음과 같이 컴포넌트를 분할할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;KanbanBord Component

&lt;ul&gt;
&lt;li&gt;List Component

&lt;ul&gt;
&lt;li&gt;Card Component

&lt;ul&gt;
&lt;li&gt;CheckList Component&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴포넌트를 만드는 데는 하향식(top-down) 과 상향식(bottom-up)의 두 가지 기본적인 접근법이 있다.
이 책의 칸반보드 앱에서는 상위(부모) 컴포넌트의 속성이 하위(자식) 컴포넌트로 전달되는 방법과
자식컴포넌트에서 이용되는 방법을 이해하는데 도움이 되도록 하향식으로 컴포넌트를 만든다.&lt;/p&gt;

&lt;p&gt;또한, 프로젝트의 체계를 유지하고 새로운 기능을 추가하거나 유지 관리하기 용이함을 위하여
&lt;strong&gt;되도록 작은 컴포넌트를 별도의 자바스크립트 파일로 만든다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래 파일들의 세부 소스는 다음 GitHub 리파지터리 chapter1 branch 를 참고 한다.
&lt;a href=&#34;https://github.com/pro-react/kanban-app&#34;&gt;https://github.com/pro-react/kanban-app&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;App.js&lt;/li&gt;
&lt;li&gt;KanbanBord.js

&lt;ul&gt;
&lt;li&gt;Kanbanboard 컴포넌트는 데이터를 속성을 통해 받고, 상태값을 필터링 하여 하위 컴포넌트인 List 컴포넌트를 렌더링하는 역할을 한다.&lt;/li&gt;
&lt;li&gt;${this.props.cards.filter()} &amp;lt;- 이 기회에 filter 의 사용법을 익혀두자.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;List.js

&lt;ul&gt;
&lt;li&gt;List 컴포넌트는 목록의 이름을 표시하고 그 안에 들어 있는 모든 Card 컴포넌트를 렌더링한다.&lt;/li&gt;
&lt;li&gt;List 컴포넌트가 속성을 통해 받은 cards 배열을 어떻게 재구성하고 하위 컴포넌트로 넘겨주는지 잘 익혀두자.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Card.js

&lt;ul&gt;
&lt;li&gt;Card 컴포넌트에 class가 아닌 className 특성이 사용된 것에 주의하자. 자세한 내용은 2장에서 다룬다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CheckList.js&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;김새미나-상태-소개-29p&#34;&gt;김새미나: 상태 소개 29p&lt;/h3&gt;

&lt;p&gt;앞에서 배웠듯이,
props는 변경 불가의 성질을 가지고 있다. 만일 props로만 컴포넌트를 구성한다면 정적인 컴포넌트가 될 것이다.
state를 사용하여 동적인 컴포넌트를 구성할 수 있다.
여기에서 주의할 점은 상태(state)는 반드시 선언 및 초기화 작업이 필요하다.
왜냐하면 state를 직접 접근하여 값을 수정하는 것이 아니라, setState()라는 비동기 함수를 통해 데이터를 갱신 할 수 있기 때문이다.
상태의 초기값은 생성자(constructor)메소드에 선언한다.
상태를 렌더링 할 때는 {this.state.stateName}
상태를 업데이트할 때는 this.setState()&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;출처: https://velopert.com/921&#34;&gt;참고 소스&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
 
class StateExample extends React.Component {
   constructor(props) {
      super(props);
 
      this.state = {
         header: &amp;quot;Header Initial state&amp;quot;,
         content: &amp;quot;Content Initial State&amp;quot;
     };
   }
 
   updateHeader(text){
       this.setState({
           header: &amp;quot;Header has changed&amp;quot;
       });
   }
 
   render() {
      return (
         &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;{this.state.header}&amp;lt;/h1&amp;gt;
            &amp;lt;h2&amp;gt;{this.state.content}&amp;lt;/h2&amp;gt;
            &amp;lt;button onClick={this.updateHeader.bind(this)}&amp;gt;Update&amp;lt;/button&amp;gt;
         &amp;lt;/div&amp;gt;
      );
   }
}
 
export default StateExample;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2장&#34;&gt;2장&lt;/h2&gt;

&lt;h3 id=&#34;김창수-리액트의-이벤트-jsx-자세히-살펴보기-34p&#34;&gt;김창수: 리액트의 이벤트/JSX 자세히 살펴보기 34p&lt;/h3&gt;

&lt;p&gt;# Handling
event
아래 내용은 React 공식 사이트에 대해서 정리했다.
&lt;a href=&#34;https://facebook.github.io/react/docs/handling-events.html&#34;&gt;https://facebook.github.io/react/docs/handling-events.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DOM
Element와 거의 유사&lt;/li&gt;
&lt;li&gt;React는 일반적으로 camelCase를 사용한다. Ex.
onClick&lt;/li&gt;
&lt;li&gt;JSX와 함께 사용할때 String 보다는 function으로 handler를 넘긴다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933214243595545&#34; alt=&#34;Inline-image-2017-02-08 13.38.30.773.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;DOM
Elements의 기본 기능을 제거하기 위해서는 명시적으로 syntheticEvent 객체의 preventDefault를 호출해 줘야 한다&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933293499658018&#34; alt=&#34;Inline-image-2017-02-08 13.38.40.254.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933626088856228&#34; alt=&#34;Inline-image-2017-02-08 13.39.20.192.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;참고 syntheticEvent : &lt;a href=&#34;https://facebook.github.io/react/docs/events.html&#34;&gt;https://facebook.github.io/react/docs/events.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ES6 class를 사용해서 정의한 사용자 component에서는 event
handler는 반드시 class에 포함되어야한다.(When you define a component using an ES6 class,
a common pattern is for an event handler to be a method on the class.)&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933740513753241&#34; alt=&#34;Inline-image-2017-02-08 13.39.33.452.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Event bind 하지 않을 경우 handler에서 this는 undefined가 된다. 이를 해결하기 위해 2가지 방법이 존재한다.&lt;/li&gt;
&lt;li&gt;Property
initializer syntax를 이용한 방법 -&amp;gt; 실험적임.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933797160181653&#34; alt=&#34;Inline-image-2017-02-08 13.39.40.616.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Arrow
function 사용&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880933833980807081&#34; alt=&#34;Inline-image-2017-02-08 13.39.44.912.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Event 종류는 공식 사이트 참조 (&lt;a href=&#34;https://facebook.github.io/react/docs/events.html&#34;&gt;https://facebook.github.io/react/docs/events.html&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;
&lt;br&gt;
# JSX
아래 내용은 React 공식 사이트에 대해서 정리했다.
&lt;a href=&#34;https://facebook.github.io/react/docs/introducing-jsx.html&#34;&gt;https://facebook.github.io/react/docs/introducing-jsx.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Javascript embeded
expression&lt;/li&gt;
&lt;li&gt;{}를 이용해서 javascript 표현을 내포할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934397907798142&#34; alt=&#34;Inline-image-2017-02-08 13.40.52.039.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Javascript 어디에나 jsx 표현법으로 표현할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934426584403780&#34; alt=&#34;Inline-image-2017-02-08 13.40.55.744.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;ldquo;에 샇인것을 스트링으로 인식한다. 심지어 &amp;ldquo;{any}&amp;ldquo;도 {any}로 된 스트링이다.&lt;/li&gt;
&lt;li&gt;camelCase
property naming convention 을 사용한다. class-&amp;gt; className, tabindex -&amp;gt;
tabIndex&lt;/li&gt;
&lt;li&gt;React DOM 은 JSX를 렌더링하기 전에 모든 값을 escape하기 때문에 자동적으로 XSS
attack을 막아준다.&lt;/li&gt;
&lt;li&gt;JSX &amp;amp;
React.createElement &amp;amp; React elements&lt;/li&gt;
&lt;li&gt;Babel이 JSX표현을 React.createElement 함수 호출로 컴파일 해준다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934481744810863&#34; alt=&#34;Inline-image-2017-02-08 13.41.02.136.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934529373337445&#34; alt=&#34;Inline-image-2017-02-08 13.41.07.984.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934565297506408&#34; alt=&#34;Inline-image-2017-02-08 13.41.12.125.png&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좀더 깊이 있는 내용은 react공식 사이트에서 확인
&lt;a href=&#34;https://facebook.github.io/react/docs/jsx-in-depth.html&#34;&gt;https://facebook.github.io/react/docs/jsx-in-depth.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSX 구문을 사용하기 위해서는 반드시 React가 동일 scope에 포함 되어야한다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934619545015597&#34; alt=&#34;Inline-image-2017-02-08 13.41.18.704.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Dot-notation이 사용가능하다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934655511130776&#34; alt=&#34;Inline-image-2017-02-08 13.41.23.107.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;사용자 정의 components는 반드시 대문자로 시작 해야한다.&lt;/li&gt;
&lt;li&gt;소문자는 html tag로 인식하고 대문자는 user-defined component로 인식한다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934718124933945&#34; alt=&#34;Inline-image-2017-02-08 13.41.30.325.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;스트링의 표현 - 아래의 표현은 서로 같다&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934766255389290&#34; alt=&#34;Inline-image-2017-02-08 13.41.36.110.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934810529621613&#34; alt=&#34;Inline-image-2017-02-08 13.41.41.532.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Props의 default 값은 true 이다&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934860394724206&#34; alt=&#34;Inline-image-2017-02-08 13.41.47.336.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Spread operator&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934908745378477&#34; alt=&#34;Inline-image-2017-02-08 13.41.53.074.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Children in JSX&lt;/li&gt;
&lt;li&gt;앞/뒤 공백은 삭제한다.&lt;/li&gt;
&lt;li&gt;비어있는 줄은 삭제한다.&lt;/li&gt;
&lt;li&gt;문장 사이에 있는 New line은 공백문자 하나로 대체한다.&lt;/li&gt;
&lt;li&gt;아래표현은 모두 동일하다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880934965684744362&#34; alt=&#34;Inline-image-2017-02-08 13.41.59.770.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Children으로 다른 component를 내포 할 수 있다&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935010631341732&#34; alt=&#34;Inline-image-2017-02-08 13.42.05.199.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;다른 타입의 children을 혼합해서 사용 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935056857716272&#34; alt=&#34;Inline-image-2017-02-08 13.42.10.632.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Javascript표현을 내포할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935109894171459&#34; alt=&#34;Inline-image-2017-02-08 13.42.17.028.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;아래와 같이 리스트 처리할 때 유요하게 쓰일 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935146012632040&#34; alt=&#34;Inline-image-2017-02-08 13.42.21.282.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Functions as
children&lt;/li&gt;
&lt;li&gt;함수로 정의된 children은 callback 으로 사용 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935201140905428&#34; alt=&#34;Inline-image-2017-02-08 13.42.27.639.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;This usage is not
common, but it works if you want to stretch what JSX is capable of.&lt;/li&gt;
&lt;li&gt;Booleans,
null, undefined는 무시된다.아래는 모두 동일&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935251871409064&#34; alt=&#34;Inline-image-2017-02-08 13.42.33.660.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Conditionally
render react element&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935302563105892&#34; alt=&#34;Inline-image-2017-02-08 13.42.39.844.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;숫자 0을 false로 인식하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935337293850904&#34; alt=&#34;Inline-image-2017-02-08 13.42.43.901.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;false,
true, null 등을 표현할때는 string으로 변환해서 사용해야한다.&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880935375539671590&#34; alt=&#34;Inline-image-2017-02-08 13.42.48.556.png&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;이재홍-칸반-앱-카드가-열려있는지-여부-확인-43p&#34;&gt;이재홍: 칸반 앱: 카드가 열려있는지 여부 확인 43p&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;칸반 앱: 카드가 열려있는지 여부 확인&lt;/strong&gt;
삼항식을 이용하여 카드의 상태 확인 후 className 조절&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return (
  &amp;lt;div className=&amp;quot;card&amp;quot;&amp;gt;
    &amp;lt;div className={
        this.state.showDetails ? &amp;quot;card_title card_title--is-open&amp;quot; : &amp;quot;card_title&amp;quot;
      } onClick={this.toggleDetails.bind(this)}&amp;gt;{this.props.title}&amp;lt;/div&amp;gt;
    {cardDetails}
  &amp;lt;/div&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://nhnent.dooray.com/files/1880962784338509408&#34; alt=&#34;Inline-image-2017-02-08 14.37.16.534.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공백&lt;/strong&gt;
html과 다르게 리엑트의 JSX는 분명한 지시가 있을 경우만 공백 출력
명시적으로 공백을 추가 하기 위해 {&amp;rdquo; &amp;ldquo;} 의 문자열을 추가&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return (
  &amp;lt;a href=&amp;quot;http://google.com&amp;quot;&amp;gt;Google&amp;lt;/a&amp;gt;{&amp;quot; &amp;quot;}
  &amp;lt;a href=&amp;quot;http://facebook.com&amp;quot;&amp;gt;Facebook&amp;lt;/a&amp;gt;{&amp;quot; &amp;quot;}
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JSX의 주석&lt;/strong&gt;
자바스크립트의 주석을 이용할 수 있음
let content = (&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
{/* 자식 주석이므로 {}로 감싼다.&lt;em&gt;/}&lt;/em&gt;
&lt;em&gt;&amp;lt;Person&lt;/em&gt;
&lt;em&gt;/&lt;/em&gt; 다중
행
주석 */
name={window.isLoggedIn ? window.name : &amp;ldquo;} // 행 끝 주석
/&amp;gt;&lt;/p&gt;

&lt;p&gt;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동적 HTML 랜더링&lt;/strong&gt;
리액트는 XSS보호 기능때문에 기본적으로 동적 HTML랜더링이 안되나 dangerouslySetInnerHTML 속성을 이용하면 가능함
&lt;img src=&#34;https://nhnent.dooray.com/files/1881001866825584089&#34; alt=&#34;Inline-image-2017-02-08 15.54.54.974.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;오태겸-jsx를-배제하고-리액트-이용-인라인-스타일링-49p&#34;&gt;오태겸: JSX를 배제하고 리액트 이용/인라인 스타일링 49p&lt;/h3&gt;

&lt;p&gt;대부분의 경우에는 JSX 를 사용하겠지만, JSX 를 사용하지 않고 리액트를 이용하는 것도 가능하다.&lt;/p&gt;

&lt;h5 id=&#34;일반-자바스크립트로-리액트-요소-만들기&#34;&gt;일반 자바스크립트로 리액트 요소 만들기&lt;/h5&gt;

&lt;p&gt;JSX 엘리먼트는 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 을 직접 호출하는 설탕 문법 (syntactic sugar) 이다.&lt;/p&gt;

&lt;p&gt;예를 들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;render() {
   return &amp;lt;div&amp;gt;Hello World&amp;lt;/div&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드는 아래와 같이 변환되어 컴파일 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;render() {
   return React.createElement(&#39;div&#39;, null, &#39;Hello World&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서, 책에 나와 있는 아래와 같은 코드가 가능하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let child1 = React.createElement(&#39;li&#39;, nul, &#39;First Text Content&#39;);
let child2 = React.createElement(&#39;li&#39;, nul, &#39;Second Text Content&#39;);
let root = React.createElement(&#39;ul&#39;, { className: &#39;my-list&#39; }, child1, child2);
React.render(root, document.getElementById(&#39;example&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;요소-팩토리&#34;&gt;요소 팩토리&lt;/h5&gt;

&lt;p&gt;React.DOM 에서 단축 팩토리 함수를 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;React.DOM.form({className:&amp;quot;commentForm&amp;quot;},
   React.DOM.input({type:&amp;quot;text&amp;quot;, placeholder:&amp;quot;Name&amp;quot;})
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드는 아래 JSX 와 동일하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;form className=&#39;commentForm&#39;&amp;gt;
    \&amp;lt;input type=&#39;text&#39; placeholder=&#39;Name&#39; /&amp;gt;
&amp;lt;/form\&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 위 코드 구조분해 할당(?) 을 이용하면 더 간결하게 작성 가능하다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;

let {
    form,
    input
} = React.DOM

class ComponentForm extends Component {
  render() {
    return form({className: &amp;quot;commentForm&amp;quot;},
              input({type:&amp;quot;text&amp;quot;, placeholder:&amp;quot;Name&amp;quot;}),
              input({type:&amp;quot;text&amp;quot;, placeholder:&amp;quot;Comment&amp;quot;}),
              input({type:&amp;quot;submit&amp;quot;, value:&amp;quot;Post&amp;quot;}))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;커스텀-팩토리&#34;&gt;커스텀 팩토리&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;ReactElement&lt;/code&gt; 를 간편하게 만들 수 있는 팩토리를 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var reactElement = React.createElement(type, props, children);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 구문을 팩토리를 이용하면 아래와 같이 사용 가능하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var div = React.createFactory(&#39;div&#39;);
var reactDivElement = div(props, children);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;React.createFactory&lt;/code&gt; 함수는 tag 와 클래스를 인자로 받는다.
따라서, 책 예제를 이용하면..&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ComponentForm.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;

let {
  form,
  input
} = React.DOM;

class ComponentForm extends Component {
  render() {
    return form({className: &amp;quot;commentForm&amp;quot;},
              input({type:&amp;quot;text&amp;quot;, placeholder:&amp;quot;Name&amp;quot;}),
              input({type:&amp;quot;text&amp;quot;, placeholder:&amp;quot;Comment&amp;quot;}),
              input({type:&amp;quot;submit&amp;quot;, value:&amp;quot;Post&amp;quot;}))
  }
}

export default ComponentForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드와 같은 클래스를 만든 후에 이를 다음과 같이 렌더링 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;App.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
import ComponentForm from &#39;./ComponentForm&#39;;

let Factory = React.createFactory(ComponentForm);

render(Factory({custom: &#39;prop&#39;}), document.getElementById(&#39;root&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;인라인-스타일링&#34;&gt;인라인 스타일링&lt;/h4&gt;

&lt;p&gt;리액트는 자바스크립트를 이용한 인라인 스타일링을 지원한다.
인라인 스타일링의 장점은 다음과 같다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;셀렉터 없이 스타일의 범위 지정 가능&lt;/li&gt;
&lt;li&gt;특정성 충돌이 예방됨&lt;/li&gt;
&lt;li&gt;소스 순서에 관계가 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;인라인-스타일-정의&#34;&gt;인라인 스타일 정의&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;스타일의 이름은 camel 표기법 적용&lt;/li&gt;
&lt;li&gt;리액트가 자동으로 적절한 단위를 지정하므로 픽셀 단위를 따로 지정할 필요 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Hello extends Component {
  render() {
    let divStyle = {
      width: 100,
      height: 30,
      padding: 5,
      backgroundColor: &#39;#ee9900&#39;
    };
    return &amp;lt;div style={divStyle}&amp;gt;Hello World&amp;lt;/div&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;박수찬-폼-처리-55p&#34;&gt;박수찬: 폼 처리 55p&lt;/h3&gt;

&lt;h4 id=&#34;리액트는-폼을-컴포넌트로서-처리하는-방식이-2가지&#34;&gt;&lt;strong&gt;리액트는 폼을 컴포넌트로서 처리하는 방식이 2가지&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;제어 컴포넌트&lt;/li&gt;
&lt;li&gt;비제어 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;제어-컴포넌트&#34;&gt;&lt;strong&gt;제어 컴포넌트&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;single source of truth 상태를 유지하는 상태에서사용자의 입력을 컨트롤하고 form(input, select, textarea 등)을 렌더링한다.&lt;/li&gt;
&lt;li&gt;이와 같이 컨트롤되는 값을 지닌 input form element를 제어 컴포넌트라 한다.&lt;/li&gt;
&lt;li&gt;예제 CheckList.js 의 defaultChecked 값이 하드코딩한 값을 반영하기 때문에 수정이 불가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
class Search extends Component {
    render() [
        return (
            &amp;lt;div&amp;gt;
                Search Term : &amp;lt;input type=&amp;quot;search&amp;quot; value=&amp;quot;React&amp;quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;위 예제 같은 경우 이미 value가 React로 선언되어있음&lt;/li&gt;
&lt;li&gt;값을 변경하기 위해선 이를 컴포넌트 상태로서 처리해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { Component } from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
class Search extends Component {
    constructor() {
        super();
        this.state = {
            searchTerm : &amp;quot;React&amp;quot;
        };
    }

    handleChange(event) {
        this.setState({searchTerm : event.target.value});   // 사용자가 입력할 때마다 searchTerm값 변경
    }

    render() [
        return (
            &amp;lt;div&amp;gt;
                Search Term : &amp;lt;input type=&amp;quot;search&amp;quot; value={this.state.searchTerm} /&amp;gt; {/* 이제 state의 searchTerm 값이 바뀔 때마다 인터페이스에 반영됨 */}
            &amp;lt;/div&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;조금 복잡해보일 수 있지만 2가지 장점이 존재

&lt;ul&gt;
&lt;li&gt;리액트가 컴포턴트를 다루는 방법을 준수한다. 상태가 인터페이스 바깥의 자바스크립트 코드에서 완전히 관리된다.&lt;/li&gt;
&lt;li&gt;이 패턴은 사용자 상호작용에 반응하거나 유효성을 검사하는 인터페이스를 구현하는데 유리하다. 예를 들어, 다음과 같이 하면 손쉽게 사용자 입력을 50자로 제한할 수 있다.&lt;/li&gt;
&lt;li&gt;this.setState({searchTerm : event.target.value.substr(0, 50)});&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;특수-사례&#34;&gt;&lt;strong&gt;특수 사례&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;TextArea와 Select를 만들 때 기억해야할 것들&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;textarea&#34;&gt;&lt;strong&gt;TextArea&lt;/strong&gt;&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;textarea&amp;gt;This is the description&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;HTML은 위 방법으로 손쉽게 가중 행 값을 제공할 수 있으나 리액트는 자바스크립트이므로 문자열 제약이 없다(ex, 행 변경은 \n 이용)&lt;/li&gt;
&lt;li&gt;리액트는 value 속성을 이용해서 정의한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;textarea value=&amp;quot;This is a description&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;select&#34;&gt;&lt;strong&gt;Select&lt;/strong&gt;&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;HTML은 selected특성을 이용해 선택한 옵션 값을 가져오지만 리액트는 다름&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;select value=&amp;quot;B&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;A&amp;quot;&amp;gt;Mobile&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;B&amp;quot;&amp;gt;Work&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;C&amp;quot;&amp;gt;Home&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;비제어-컴포넌트&#34;&gt;&lt;strong&gt;비제어 컴포넌트&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;제어 컴포넌트는 form 데이터를 리액트 컴포넌트가 관리하지만&amp;hellip;&lt;/li&gt;
&lt;li&gt;비제어 컴포넌트는 DOM 자신이 직접 form data를 관리하도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit(event) {
    alert(&#39;A name was submitted: &#39; + this.input.value);
    event.preventDefault();
  }

  render() {
    return (
      &amp;lt;form onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;label&amp;gt;
          Name:
          &amp;lt;input type=&amp;quot;text&amp;quot; ref={(input) =&amp;gt; this.input = input} /&amp;gt;
        &amp;lt;/label&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
}

ReactDOM.render(
  &amp;lt;NameForm /&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;책에 있는 칸반 앱의 태스크 체크박스가 &lt;strong&gt;제어 컴포넌트&lt;/strong&gt;라고 한 바가 있다. 새 태스크를 추가할 때 이용할 필드는 &lt;strong&gt;비제어 컴포넌트&lt;/strong&gt;로 추가해보자&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class CheckList extends Component {
    render() {
        let tasks = this.props.tasks.map((task) =&amp;gt; (
            &amp;lt;li className=&amp;quot;checklist__task&amp;quot;&amp;gt;
                &amp;lt;input type=&amp;quot;checkbox&amp;quot; defaultChecked={task.done} /&amp;gt;
                {task.name}
                &amp;lt;a href=&amp;quot;#&amp;quot; className=&amp;quot;checklist__task--remove&amp;quot; /&amp;gt;
            &amp;lt;/li&amp;gt;
        ));
        return (
            &amp;lt;div className=&amp;quot;checklist&amp;quot;&amp;gt;
                &amp;lt;ul&amp;gt;{tasks}&amp;lt;/ul&amp;gt;
                &amp;lt;input type=&amp;quot;text&amp;quot; className=&amp;quot;checklist--add-tast&amp;quot; placeholder=&amp;quot;Type then hit Enter to add a task&amp;quot; /&amp;gt; {/* 새롭게 추가된 부분 */}
            &amp;lt;/div&amp;gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;value 속성을 지정하지 않았으므로 자유롭게 텍스트 필드에 원하는 내용을 입력할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;김새미나-가상-dom의-동작-방식-61p&#34;&gt;김새미나: 가상 DOM의 동작 방식 61p&lt;/h3&gt;

&lt;p&gt;가상 DOM과 실제 DOM을 동일하게 만드는데 필요한 최소 변경 횟수를 알아내는 프로세스를 조정이라고 한다.
리액트 가상 DOM은 효율적으로 DOM을 변경하기 위해 아래와 같이 몇가지 사항을 가정한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DOM 요소가 서로 다른 유형일 경우(div를 span으로 변경) span을 생성 삽입&lt;/li&gt;
&lt;li&gt;컴포넌트가 서로 다른 유형인 경우에도 위와 동일하다.&lt;/li&gt;
&lt;li&gt;동일한 유형인 경우
3-1. DOM요소인 경우(&amp;lt;div id=“before” /&amp;gt;를 &amp;lt;div id=“after” /&amp;gt;로 변경) 특성과 스타일만 변경
3-2. 컴포넌트인 경우(&amp;lt;Contact details={false} /&amp;gt;를 &amp;lt;Contact details={true} /&amp;gt;로 변경) 새로운 속성을 현재 컴포넌트로 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 알고리즘은 정말 효율적이고 엄청난 렌더링 속도를 가져온다.
하지만 반복되는 항목 리스트 인 경우, 한 리스트를 다른 리스트로 변환하는 최상의 방법을 말하기는 쉽지 않다.
이런 이유로, React는 key특성을 도입했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&#34;color:#e11d21&#34;&gt;key는&lt;/span&gt;&lt;/strong&gt; 트리간에 항목 삽입, 삭제, 대체, 이동이 발생했는지 파악하기 위해 빠른 조회를 가능하게 하는 고유 식별자이다.
컴포넌트 또한 루프 안에 컴포넌트를 생성할 때 마다 각 자식에 대한 key를 지정할 수 있다. (&lt;Card key=“ ” ... /&gt;)&lt;/p&gt;

&lt;p&gt;React는 컴포넌트를 렌더링할때 항상 가상 DOM을 대상으로 작업한다.
&lt;strong&gt;&lt;span style=&#34;color:#e11d21&#34;&gt;ref는&lt;/span&gt;&lt;/strong&gt; 실제 DOM에 직접적으로 접근하고자 할 때 사용하는데, ref로만 처리 할 수 있는 상황을 제외하곤 가능한 사용하지 않도록 권장하고 있다.
대표적으로 사용자가 클릭하면 텍스트 입력으로 포커스를 전환하는 경우이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;출처: https://velopert.com/1148&#34;&gt;참고 소스&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Hello extends React.Component {
  render() {
   return (
       &amp;lt;div&amp;gt;
           &amp;lt;input ref={ref =&amp;gt; this.input = ref}&amp;gt;
            &amp;lt;/input&amp;gt;
          &amp;lt;/div&amp;gt;
        )
  }

  componentDidMount() {
   this.input.value = &amp;quot;I used ref to do this&amp;quot;;
  }

}
ReactDOM.render(
  &amp;lt;Hello/&amp;gt;,
  document.getElementById(&#39;app&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;p.s 선영선배님은 차주 출장 예정으로 스터디 참석하지 못하여 이번 리딩에서 제외하였습니다. 하지만 3장에서 엄청난 리딩 분담을 드릴 예정이니 1장2장 공부 열심히 해주시기 바랍니다. :) 알랍~&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://ne-mis.github.io/study-react.js/about/</link>
      <pubDate>Thu, 09 Feb 2017 15:52:28 +0900</pubDate>
      
      <guid>https://ne-mis.github.io/study-react.js/about/</guid>
      <description>

&lt;h1 id=&#34;nhn-ent-mis-개발실의-react-js-스터디&#34;&gt;NHN Ent. MIS 개발실의 React.JS 스터디&lt;/h1&gt;
</description>
    </item>
    
  </channel>
</rss>